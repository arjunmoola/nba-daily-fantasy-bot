// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries_backend.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteRosterPlayerByDateAndDiscordIdAndPlayerName = `-- name: DeleteRosterPlayerByDateAndDiscordIdAndPlayerName :exec
delete from daily_roster dr where dr.date = $1 and dr.discord_player_id = $2 and dr.nba_player_uid = $3
`

type DeleteRosterPlayerByDateAndDiscordIdAndPlayerNameParams struct {
	Date         pgtype.Date
	Discordid    string
	Nbaplayeruid pgtype.UUID
}

func (q *Queries) DeleteRosterPlayerByDateAndDiscordIdAndPlayerName(ctx context.Context, arg DeleteRosterPlayerByDateAndDiscordIdAndPlayerNameParams) error {
	_, err := q.db.Exec(ctx, deleteRosterPlayerByDateAndDiscordIdAndPlayerName, arg.Date, arg.Discordid, arg.Nbaplayeruid)
	return err
}

const findNbaPlayerByName = `-- name: FindNbaPlayerByName :one
select nba_player_uid, nba_player_id, name, date, against_team, dollar_value, fantasy_score, team_id, position, avg_pts, avg_reb, avg_stl, avg_ast, avg_tov, avg_blk, jersey_num, status, reb, ast, pts, blk, stl, tov from nba_players where name = $1
`

func (q *Queries) FindNbaPlayerByName(ctx context.Context, name string) (NbaPlayer, error) {
	row := q.db.QueryRow(ctx, findNbaPlayerByName, name)
	var i NbaPlayer
	err := row.Scan(
		&i.NbaPlayerUid,
		&i.NbaPlayerID,
		&i.Name,
		&i.Date,
		&i.AgainstTeam,
		&i.DollarValue,
		&i.FantasyScore,
		&i.TeamID,
		&i.Position,
		&i.AvgPts,
		&i.AvgReb,
		&i.AvgStl,
		&i.AvgAst,
		&i.AvgTov,
		&i.AvgBlk,
		&i.JerseyNum,
		&i.Status,
		&i.Reb,
		&i.Ast,
		&i.Pts,
		&i.Blk,
		&i.Stl,
		&i.Tov,
	)
	return i, err
}

const findNbaPlayerByUid = `-- name: FindNbaPlayerByUid :one
select nba_player_uid, nba_player_id, name, date, against_team, dollar_value, fantasy_score, team_id, position, avg_pts, avg_reb, avg_stl, avg_ast, avg_tov, avg_blk, jersey_num, status, reb, ast, pts, blk, stl, tov from nba_players where nba_player_uid = $1
`

func (q *Queries) FindNbaPlayerByUid(ctx context.Context, nbaplayeruid pgtype.UUID) (NbaPlayer, error) {
	row := q.db.QueryRow(ctx, findNbaPlayerByUid, nbaplayeruid)
	var i NbaPlayer
	err := row.Scan(
		&i.NbaPlayerUid,
		&i.NbaPlayerID,
		&i.Name,
		&i.Date,
		&i.AgainstTeam,
		&i.DollarValue,
		&i.FantasyScore,
		&i.TeamID,
		&i.Position,
		&i.AvgPts,
		&i.AvgReb,
		&i.AvgStl,
		&i.AvgAst,
		&i.AvgTov,
		&i.AvgBlk,
		&i.JerseyNum,
		&i.Status,
		&i.Reb,
		&i.Ast,
		&i.Pts,
		&i.Blk,
		&i.Stl,
		&i.Tov,
	)
	return i, err
}

const getAllTodaysNbaPlayers = `-- name: GetAllTodaysNbaPlayers :many
select np.nba_player_uid, np.nba_player_id, np.name, np.date, np.against_team, np.dollar_value, np.fantasy_score, np.team_id, np.position, np.avg_pts, np.avg_reb, np.avg_stl, np.avg_ast, np.avg_tov, np.avg_blk, np.jersey_num, np.status, np.reb, np.ast, np.pts, np.blk, np.stl, np.tov from nba_players np order by np.dollar_value desc limit 25
`

func (q *Queries) GetAllTodaysNbaPlayers(ctx context.Context) ([]NbaPlayer, error) {
	rows, err := q.db.Query(ctx, getAllTodaysNbaPlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NbaPlayer
	for rows.Next() {
		var i NbaPlayer
		if err := rows.Scan(
			&i.NbaPlayerUid,
			&i.NbaPlayerID,
			&i.Name,
			&i.Date,
			&i.AgainstTeam,
			&i.DollarValue,
			&i.FantasyScore,
			&i.TeamID,
			&i.Position,
			&i.AvgPts,
			&i.AvgReb,
			&i.AvgStl,
			&i.AvgAst,
			&i.AvgTov,
			&i.AvgBlk,
			&i.JerseyNum,
			&i.Status,
			&i.Reb,
			&i.Ast,
			&i.Pts,
			&i.Blk,
			&i.Stl,
			&i.Tov,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNbaPlayersWithTeam = `-- name: GetNbaPlayersWithTeam :many
select np.name as player_name, t.abbr as team_name, at.abbr as against_team_name, np.nba_player_uid, np.nba_player_id, np.name, np.date, np.against_team, np.dollar_value, np.fantasy_score, np.team_id, np.position, np.avg_pts, np.avg_reb, np.avg_stl, np.avg_ast, np.avg_tov, np.avg_blk, np.jersey_num, np.status, np.reb, np.ast, np.pts, np.blk, np.stl, np.tov from nba_players np join teams t on t.team_id = np.team_id join teams at on np.against_team = at.team_id where np.date = $1 order by np.dollar_value desc
`

type GetNbaPlayersWithTeamRow struct {
	PlayerName      string
	TeamName        pgtype.Text
	AgainstTeamName pgtype.Text
	NbaPlayerUid    pgtype.UUID
	NbaPlayerID     int32
	Name            string
	Date            string
	AgainstTeam     pgtype.Int4
	DollarValue     pgtype.Int4
	FantasyScore    pgtype.Float8
	TeamID          pgtype.Int4
	Position        string
	AvgPts          pgtype.Float4
	AvgReb          pgtype.Float4
	AvgStl          pgtype.Float4
	AvgAst          pgtype.Float4
	AvgTov          pgtype.Float4
	AvgBlk          pgtype.Float4
	JerseyNum       pgtype.Text
	Status          pgtype.Text
	Reb             pgtype.Int4
	Ast             pgtype.Int2
	Pts             pgtype.Int2
	Blk             pgtype.Int2
	Stl             pgtype.Int2
	Tov             pgtype.Int2
}

func (q *Queries) GetNbaPlayersWithTeam(ctx context.Context, date string) ([]GetNbaPlayersWithTeamRow, error) {
	rows, err := q.db.Query(ctx, getNbaPlayersWithTeam, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNbaPlayersWithTeamRow
	for rows.Next() {
		var i GetNbaPlayersWithTeamRow
		if err := rows.Scan(
			&i.PlayerName,
			&i.TeamName,
			&i.AgainstTeamName,
			&i.NbaPlayerUid,
			&i.NbaPlayerID,
			&i.Name,
			&i.Date,
			&i.AgainstTeam,
			&i.DollarValue,
			&i.FantasyScore,
			&i.TeamID,
			&i.Position,
			&i.AvgPts,
			&i.AvgReb,
			&i.AvgStl,
			&i.AvgAst,
			&i.AvgTov,
			&i.AvgBlk,
			&i.JerseyNum,
			&i.Status,
			&i.Reb,
			&i.Ast,
			&i.Pts,
			&i.Blk,
			&i.Stl,
			&i.Tov,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamByPlayerUid = `-- name: GetTeamByPlayerUid :many
select t.team_id, t.name, t.abbr from nba_players np join teams t on t.team_id = np.team_id where np.nba_player_uid = $1
`

func (q *Queries) GetTeamByPlayerUid(ctx context.Context, playerid pgtype.UUID) ([]Team, error) {
	rows, err := q.db.Query(ctx, getTeamByPlayerUid, playerid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(&i.TeamID, &i.Name, &i.Abbr); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodaysGlobalLeaderboard = `-- name: GetTodaysGlobalLeaderboard :many
with roster_totals as ( select dr.discord_player_id, sum(np.fantasy_score) as total_score from daily_roster dr join nba_players np on np.nba_player_uid = dr.nba_player_uid where dr.date = $1 group by dr.discord_player_id order by total_score desc limit 100 ) select dr.discord_player_id, np.nba_player_id, dr.nba_player_uid, dr.date, dr.nickname, dr.position as position, np.name, np.dollar_value, np.fantasy_score from daily_roster dr join nba_players np on np.nba_player_uid = dr.nba_player_uid join roster_totals rr on dr.discord_player_id = rr.discord_player_id where dr.date = $1 order by rr.total_score desc, np.fantasy_score desc
`

type GetTodaysGlobalLeaderboardRow struct {
	DiscordPlayerID string
	NbaPlayerID     int32
	NbaPlayerUid    pgtype.UUID
	Date            pgtype.Date
	Nickname        string
	Position        DailyRosterPosition
	Name            string
	DollarValue     pgtype.Int4
	FantasyScore    pgtype.Float8
}

func (q *Queries) GetTodaysGlobalLeaderboard(ctx context.Context, date pgtype.Date) ([]GetTodaysGlobalLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getTodaysGlobalLeaderboard, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTodaysGlobalLeaderboardRow
	for rows.Next() {
		var i GetTodaysGlobalLeaderboardRow
		if err := rows.Scan(
			&i.DiscordPlayerID,
			&i.NbaPlayerID,
			&i.NbaPlayerUid,
			&i.Date,
			&i.Nickname,
			&i.Position,
			&i.Name,
			&i.DollarValue,
			&i.FantasyScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodaysLeaderboardByGuildId = `-- name: GetTodaysLeaderboardByGuildId :many
select dr.discord_player_id, np.nba_player_id, dr.nba_player_uid, dr.date, dr.nickname, dr.position as position, np.name, np.dollar_value, np.fantasy_score from daily_roster dr join nba_players np on np.nba_player_uid = dr.nba_player_uid join discord_player_guilds dpg on dpg.discord_player_id = dr.discord_player_id where dr.date = $1 and dpg.guild_id = $2 order by np.fantasy_score desc limit 1000
`

type GetTodaysLeaderboardByGuildIdParams struct {
	Date    pgtype.Date
	Guildid string
}

type GetTodaysLeaderboardByGuildIdRow struct {
	DiscordPlayerID string
	NbaPlayerID     int32
	NbaPlayerUid    pgtype.UUID
	Date            pgtype.Date
	Nickname        string
	Position        DailyRosterPosition
	Name            string
	DollarValue     pgtype.Int4
	FantasyScore    pgtype.Float8
}

func (q *Queries) GetTodaysLeaderboardByGuildId(ctx context.Context, arg GetTodaysLeaderboardByGuildIdParams) ([]GetTodaysLeaderboardByGuildIdRow, error) {
	rows, err := q.db.Query(ctx, getTodaysLeaderboardByGuildId, arg.Date, arg.Guildid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTodaysLeaderboardByGuildIdRow
	for rows.Next() {
		var i GetTodaysLeaderboardByGuildIdRow
		if err := rows.Scan(
			&i.DiscordPlayerID,
			&i.NbaPlayerID,
			&i.NbaPlayerUid,
			&i.Date,
			&i.Nickname,
			&i.Position,
			&i.Name,
			&i.DollarValue,
			&i.FantasyScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodaysNbaPlayersByPosition = `-- name: GetTodaysNbaPlayersByPosition :many
select np.nba_player_uid, np.nba_player_id, np.name, np.date, np.against_team, np.dollar_value, np.fantasy_score, np.team_id, np.position, np.avg_pts, np.avg_reb, np.avg_stl, np.avg_ast, np.avg_tov, np.avg_blk, np.jersey_num, np.status, np.reb, np.ast, np.pts, np.blk, np.stl, np.tov from nba_players np where np.position = $1 order by np.dollar_value desc limit 5
`

func (q *Queries) GetTodaysNbaPlayersByPosition(ctx context.Context, position string) ([]NbaPlayer, error) {
	rows, err := q.db.Query(ctx, getTodaysNbaPlayersByPosition, position)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NbaPlayer
	for rows.Next() {
		var i NbaPlayer
		if err := rows.Scan(
			&i.NbaPlayerUid,
			&i.NbaPlayerID,
			&i.Name,
			&i.Date,
			&i.AgainstTeam,
			&i.DollarValue,
			&i.FantasyScore,
			&i.TeamID,
			&i.Position,
			&i.AvgPts,
			&i.AvgReb,
			&i.AvgStl,
			&i.AvgAst,
			&i.AvgTov,
			&i.AvgBlk,
			&i.JerseyNum,
			&i.Status,
			&i.Reb,
			&i.Ast,
			&i.Pts,
			&i.Blk,
			&i.Stl,
			&i.Tov,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodaysRosterByDiscordId = `-- name: GetTodaysRosterByDiscordId :many
select dr.guild_id, dr.discord_player_id, dr.nba_player_uid, dr.date, dr.nickname, dr.position, np.nba_player_uid, np.nba_player_id, np.name, np.dollar_value from daily_roster dr join nba_players np on np.nba_player_uid = dr.nba_player_uid where dr.discord_player_id = $1 and dr.date = $2
`

type GetTodaysRosterByDiscordIdParams struct {
	Discordid string
	Date      pgtype.Date
}

type GetTodaysRosterByDiscordIdRow struct {
	GuildID         string
	DiscordPlayerID string
	NbaPlayerUid    pgtype.UUID
	Date            pgtype.Date
	Nickname        string
	Position        DailyRosterPosition
	NbaPlayerUid_2  pgtype.UUID
	NbaPlayerID     int32
	Name            string
	DollarValue     pgtype.Int4
}

func (q *Queries) GetTodaysRosterByDiscordId(ctx context.Context, arg GetTodaysRosterByDiscordIdParams) ([]GetTodaysRosterByDiscordIdRow, error) {
	rows, err := q.db.Query(ctx, getTodaysRosterByDiscordId, arg.Discordid, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTodaysRosterByDiscordIdRow
	for rows.Next() {
		var i GetTodaysRosterByDiscordIdRow
		if err := rows.Scan(
			&i.GuildID,
			&i.DiscordPlayerID,
			&i.NbaPlayerUid,
			&i.Date,
			&i.Nickname,
			&i.Position,
			&i.NbaPlayerUid_2,
			&i.NbaPlayerID,
			&i.Name,
			&i.DollarValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodaysRosterPrice = `-- name: GetTodaysRosterPrice :many
select np.dollar_value from daily_roster dr join nba_players np on np.nba_player_uid = dr.nba_player_uid where dr.discord_player_id = $1 and dr.date = $2 and dr.position <> $3::daily_roster_position
`

type GetTodaysRosterPriceParams struct {
	Discordid string
	Date      pgtype.Date
	Position  DailyRosterPosition
}

func (q *Queries) GetTodaysRosterPrice(ctx context.Context, arg GetTodaysRosterPriceParams) ([]pgtype.Int4, error) {
	rows, err := q.db.Query(ctx, getTodaysRosterPrice, arg.Discordid, arg.Date, arg.Position)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Int4
	for rows.Next() {
		var dollar_value pgtype.Int4
		if err := rows.Scan(&dollar_value); err != nil {
			return nil, err
		}
		items = append(items, dollar_value)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeksLeaderboardByGuildId = `-- name: GetWeeksLeaderboardByGuildId :many
select dr.discord_player_id, dr.nickname, sum(np.fantasy_score) as fantasy_score from daily_roster dr join nba_players np on np.nba_player_uid = dr.nba_player_uid join discord_player_guilds dpg on dpg.discord_player_id = dr.discord_player_id where dpg.guild_id = $1 and dr.date < $2 and dr.date > $3 group by dr.discord_player_id, dr.nickname order by fantasy_score desc limit 100
`

type GetWeeksLeaderboardByGuildIdParams struct {
	Guildid  string
	Endday   pgtype.Date
	Startday pgtype.Date
}

type GetWeeksLeaderboardByGuildIdRow struct {
	DiscordPlayerID string
	Nickname        string
	FantasyScore    int64
}

func (q *Queries) GetWeeksLeaderboardByGuildId(ctx context.Context, arg GetWeeksLeaderboardByGuildIdParams) ([]GetWeeksLeaderboardByGuildIdRow, error) {
	rows, err := q.db.Query(ctx, getWeeksLeaderboardByGuildId, arg.Guildid, arg.Endday, arg.Startday)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeeksLeaderboardByGuildIdRow
	for rows.Next() {
		var i GetWeeksLeaderboardByGuildIdRow
		if err := rows.Scan(&i.DiscordPlayerID, &i.Nickname, &i.FantasyScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGuildForPlayerId = `-- name: InsertGuildForPlayerId :exec
insert into discord_player_guilds (discord_player_id, guild_id) values ($1, $2) on conflict (discord_player_id, guild_id) do nothing
`

type InsertGuildForPlayerIdParams struct {
	Discordplayerid string
	Guildid         string
}

func (q *Queries) InsertGuildForPlayerId(ctx context.Context, arg InsertGuildForPlayerIdParams) error {
	_, err := q.db.Exec(ctx, insertGuildForPlayerId, arg.Discordplayerid, arg.Guildid)
	return err
}

const isLocked = `-- name: IsLocked :one
select il.date, il.lock_time from is_locked il where il.date = $1
`

func (q *Queries) IsLocked(ctx context.Context, date pgtype.Date) (IsLocked, error) {
	row := q.db.QueryRow(ctx, isLocked, date)
	var i IsLocked
	err := row.Scan(&i.Date, &i.LockTime)
	return i, err
}

const isTodayLocked = `-- name: IsTodayLocked :one
select il.date, il.lock_time from is_locked il where il.date = current_date
`

func (q *Queries) IsTodayLocked(ctx context.Context) (IsLocked, error) {
	row := q.db.QueryRow(ctx, isTodayLocked)
	var i IsLocked
	err := row.Scan(&i.Date, &i.LockTime)
	return i, err
}

const saveRosterChoice = `-- name: SaveRosterChoice :exec
insert into daily_roster (discord_player_id, nba_player_uid, date, nickname, position, guild_id) values ($1, $2, $3, $4, $5::daily_roster_position, 'null') on conflict(discord_player_id, date, position) do update set nba_player_uid = $2, position = $5::daily_roster_position
`

type SaveRosterChoiceParams struct {
	Discordplayerid string
	Nbaplayeruid    pgtype.UUID
	Date            pgtype.Date
	Nickname        string
	Position        DailyRosterPosition
}

func (q *Queries) SaveRosterChoice(ctx context.Context, arg SaveRosterChoiceParams) error {
	_, err := q.db.Exec(ctx, saveRosterChoice,
		arg.Discordplayerid,
		arg.Nbaplayeruid,
		arg.Date,
		arg.Nickname,
		arg.Position,
	)
	return err
}
